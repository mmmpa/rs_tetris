use crate::*;

pub struct Cell<A, Rot: RotationState>(A, Rot);

pub trait CellExt {
    type Mino;
    type State;

    fn cells() -> &'static [(i8, i8)];
}

#[macro_export]
macro_rules! mino2 {
    ( $mino:tt, $state:tt, $cells:expr ) => {
        impl CellExt for Cell<$mino, $state> {
            type Mino = $mino;
            type State = $state;

            fn cells() -> &'static [(i8, i8)] {
                &$cells
            }
        }
    };
}

// ⬛⬜⬛⬛
// -----
// ⬛
// ⬜
// ⬛
// ⬛
// -----
// ⬛⬛⬜⬛
// -----
// ⬛
// ⬛
// ⬜
// ⬛
mino2!(A, State0, [(0, 0), (1, 0), (2, 0), (3, 0)]);
mino2!(A, StateR, [(0, 0), (0, 1), (0, 2), (0, 3)]);
mino2!(A, State2, [(0, 0), (1, 0), (2, 0), (3, 0)]);
mino2!(A, StateL, [(0, 0), (0, 1), (0, 2), (0, 3)]);

// ⬛⬛
// ⬛⬛
mino2!(B, State0, [(1, 1), (0, 1), (1, 0), (0, 0)]);
mino2!(B, StateR, [(1, 1), (0, 1), (1, 0), (0, 0)]);
mino2!(B, State2, [(1, 1), (0, 1), (1, 0), (0, 0)]);
mino2!(B, StateL, [(1, 1), (0, 1), (1, 0), (0, 0)]);

// 　⬛⬛
// ⬛⬜
// -----
// ⬛
// ⬜⬛
// 　⬛
// -----
// 　⬜⬛
// ⬛⬛
// -----
// ⬛
// ⬛⬜
// 　⬛
mino2!(C, State0, [(1, 0), (2, 0), (0, 1), (1, 1)]);
mino2!(C, StateR, [(0, 0), (0, 1), (1, 1), (1, 2)]);
mino2!(C, State2, [(1, 0), (2, 0), (0, 1), (1, 1)]);
mino2!(C, StateL, [(0, 0), (0, 1), (1, 1), (1, 2)]);

// ⬛⬛
// 　⬜⬛
// -----
// 　⬛
// ⬜⬛
// ⬛
// -----
// ⬛⬜
// 　⬛⬛
// -----
// 　⬛
// ⬛⬜
// ⬛
mino2!(D, State0, [(0, 0), (1, 0), (1, 1), (2, 1)]);
mino2!(D, StateR, [(1, 0), (0, 1), (1, 1), (0, 2)]);
mino2!(D, State2, [(0, 0), (1, 0), (1, 1), (2, 1)]);
mino2!(D, StateL, [(1, 0), (0, 1), (1, 1), (0, 2)]);

// ⬛
// ⬛⬜⬛
// -----
// ⬛⬛
// ⬜
// ⬛
// -----
// ⬛⬜⬛
// 　　⬛
// -----
// 　⬛
// 　⬜
// ⬛⬛
mino2!(E, State0, [(0, 0), (0, 1), (1, 1), (2, 1)]);
mino2!(E, StateR, [(1, 0), (0, 0), (0, 1), (0, 2)]);
mino2!(E, State2, [(2, 1), (0, 0), (1, 0), (2, 0)]);
mino2!(E, StateL, [(0, 2), (1, 0), (1, 1), (1, 2)]);

// 　　⬛
// ⬛⬜⬛
// -----
// ⬛
// ⬜
// ⬛⬛
// -----
// ⬛⬜⬛
// ⬛
// -----
// ⬛⬛
// 　⬜
// 　⬛
mino2!(F, State0, [(2, 0), (0, 1), (1, 1), (2, 1)]);
mino2!(F, StateR, [(1, 2), (0, 0), (0, 1), (0, 2)]);
mino2!(F, State2, [(0, 1), (0, 0), (1, 0), (2, 0)]);
mino2!(F, StateL, [(0, 0), (1, 0), (1, 1), (1, 2)]);

// 　⬛
// ⬛⬜⬛
// -----
// ⬛
// ⬜⬛
// ⬛
// -----
// ⬛⬜⬛
// 　⬛
// -----
// 　⬛
// ⬛⬜
// 　⬛
mino2!(G, State0, [(1, 0), (0, 1), (1, 1), (2, 1)]);
mino2!(G, StateR, [(1, 1), (0, 0), (0, 1), (0, 2)]);
mino2!(G, State2, [(1, 1), (0, 0), (1, 0), (2, 0)]);
mino2!(G, StateL, [(0, 1), (1, 0), (1, 1), (1, 2)]);
